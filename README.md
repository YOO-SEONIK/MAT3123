# MAT3123
MAT3123-Final Project

Final 프로젝트의 목표는 속이 빈 고무 패킹의 열–기계 거동을 물리식으로 라벨링해 합성 데이터셋을 만들고, 이를 학습한 MLP서로게이트로 온도 변동 시나리오에서 응력 기반 $ε-N$ 피로수명을 빠르게 예측한다.

1. Data Setting (1~5)
2. Machine Learning (6~9)
3. PyTorch Surrogate Training (10)
4. Sensitivity Analysis (11~12)
5. Thermal-stress Simulation and Fatigue Assessment (13~15)
6. Life Prediction (16~17)
17개의 코드셀로 이루어져 있다.

# Data Setting
## 1. 노트북 환경 체크 + 그래프 기본 설정
Python, Numpy, Pandas의 버전을 확인하고 그래프를 설정값을 조절한다.

## 2. 내부 대류 열전달 계수 h
이 단계에서는 관 내 유동의 내부 대류 열전달계수 $h$를 계산해 이후 온도장 및 응력 해석의 경계조건으로 사용한다. 먼저 $20\text{–}80~^\circ\mathrm{C}$ 범위에서 물의 평균 물성치(열전도도 $k$, 점도 $\mu$, 밀도 $\rho$, 비열 $c_p$, Prandtl 수 $\mathrm{Pr}$)를 정의한다. 유속 $U$와 관내경 $D_i$로 Reynolds 수를 $\mathrm{Re}=\dfrac{{\rho}UD_i}{\mu}$ 로 계산하고, 유동 상태를 판별한다. 층류 $(\mathrm{Re}<2300)$ 에서는 완전발달 내부유동 가정으로 $\mathrm{Nu}=3.66$ 을 사용한다. 난류 $(\mathrm{Re}\ge 2300)$ 에서는 Dittus–Boelter 상관식 $\mathrm{Nu}=0.023,\mathrm{Re}^{0.8}\mathrm{Pr}^{,n}$ 을 쓰며, 가열은 $n=0.4$, 냉각은 $n=0.3$ 을 사용한다. 마지막으로 $h=\dfrac{\mathrm{Nu}k}{D_i}$ 로 환산한다. 이 근사는 원형 관, 매끈한 벽, 충분히 긴 관, 상수 물성 등의 단순화를 포함하므로, 고온/점도 변화가 큰 경우나 비원형 덕트, 입구영향이 큰 짧은 관에서는 보정 또는 다른 상관식 검토가 필요하다.

## 3. 고무 링의 온도 분포 T(r)
이 단계는 속 빈 원통(고무 링)의 반지름 방향 정상상태 온도분포 $T(r)$를 구한다. 축대칭, 축방향 열흐름 무시, 고체 내부 생성열을 $0$, 열전도도 $k$ 일정 가정에서 지배식은 $\dfrac{\mathrm{d}}{\mathrm{d}r}\left(r\dfrac{\mathrm{d}T}{\mathrm{d}r}\right)=0$ 이고 해는 $T(r)=C1ln(r)+C2$ 이다. 내부/외부 표면에는 대류 경계가 적용된다: $r=r_i$ 에서 $-k\dfrac{\mathrm{d}T}{\mathrm{d}r}=h_i(T-T_{i,\infty})$, $r=r_o$ 에서 $-k\dfrac{\mathrm{d}T}{\mathrm{d}r}=h_o(T-T_{o,\infty})$. 이를 C1, C2에 대한 선형 2x2 방정식으로 정리해 행렬 $M \cdot [C1  C2]^T = rhs$ 를 만들고, $numpy$ 선형해법으로 $C1$, $C2$ 를 푼다. 그런 다음 $r_i~r_o$ 사이를 균일 격자로 샘플링해 $T(r)=C1ln(r)+C2$ 값을 계산해 반환한다. 출력은 반지름 벡터 $r[m]$와 온도 벡터 $T[^\circ\mathrm{C}]$ 이며, 이 분포는 이후 열팽창 변형률 및 응력 근사 계산의 입력으로 사용된다. 가정상 $k$ 와 물성은 상수이고, 복사나 비선형 효과는 무시한다.

## 4. 온도→물성/열팽창→응력(근사) 라벨러
이 단계는 주어진 운전/재료 조건에서 고무 링의 최대 등가응력과 합격/불합격 라벨을 자동 생성하는 핵심 라벨러다. 먼저 평균 온도 $T_{avg}$로 온도의존 등가 탄성계수 $E(T)=E_{25}\exp\(-\beta\(T-25))$를 계산한다. 이어 고무의 선형 열팽창 계수 $\alpha$와 기준온도 $T_{ref}$를 사용해 열팽창 변형률 분포 $ε_{th}(r)=\alpha\(T(r)-T_{ref})$을 얻는다. 구조 거동은 단순화하여 외벽 둘레변형이 거의 $0$이라고 가정하고, 열팽창에 역행하는 기계 변형을 $ε_{mech}=-ε_{th}$로 두어 원주방향 응력을 $\sigma_\theta=\dfrac{E}{1-\nu}\cdot\varepsilon_{\mathrm{mech}}$ 로 근사한다. 이 분포의 절댓값 최대치를 최대 등가응력(보수적 von Mises 근사)으로 사용한다. label_one_sample은 다음 순서로 동작한다: (1) 유속 $U$, 내경 $D_i$로 내부 대류계수 $h_i$ 계산, (2) 내부/외부 대류 경계와 고무 열전도율 $k$로 속 빈 원통의 정상상태 온도장 $T(r)$ 해석, (3) $T_{avg}$로 $E$ 산출, (4) $ε_{th}(r)$ 계산, (5) $σ_θ(r)$ 와 그 최대치 max_vm 산출, (6) 허용응력 $σ_{allow}$와 비교해 pass_flag를 $1$과 $0$으로 부여. 반환에는 $r$, $T(r)$, $E$, $ε_th(r)$, $σ_θ(r)$, max_vm, pass_flag, $h_i$가 포함되어 이후 데이터셋 생성과 모델 학습에 바로 쓸 수 있다. 선형 탄성, 등방 열팽창, $ν≈0.49$, 정상상태 열전달, 접촉/구속 단순화 등을 가정한다.


## 5. 랜덤 데이터셋 생성 + 빠른 확인용 플롯
이 단계는 학습에 사용할 표준화된 테이블 데이터를 자동 생성한다. 먼저 난수 시드로 재현성을 확보한 뒤, 운전/재료 변수($U$, $T_{in}$, $T_{amb}$, $E_{25}$, $β$, $α$, $h_o$)를 현실 범위에서 균일 샘플링한다. 각 샘플마다 4번의 물리 라벨러를 호출해 최대 등가응력 max_vm(회귀 타깃)과 허용응력 기준 pass(분류 타깃)를 계산하고, 이를 하나의 표(df)에 쌓아 CSV로 저장한다. 생성된 df.head()와 describe()를 통해 분포와 스케일을 즉시 점검하며, 컬럼은 입력 7개($U$, $T_{in}$, $T_{amb}$, $E_{25}$, $β$, $α$, $h_o$)와 출력 2개(max_vm, pass)로 명확히 분리된다. 이어 개별 프로파일들의 평균이 아니라 평균 파라미터에서 단일 해석을 수행해, 평균 조건에서의 반지름 방향 온도 $T(r)$와 근사 hoop 응력 분포를 플롯하여 물리적으로 가능한지 시각적으로 검증한다. 마지막으로 데이터셋 합격률(pass_rate)과 평균 조건의 내부 대류계수 $h_i$, max_vm을 함께 출력해 기준을 잡는다. 이 산출물은 이후 scikit-learn/PyTorch에 그대로 투입할 수 있는 깔끔한 입력-타깃 테이블이며, 학습/검증 분할, 스케일링, 라벨 균형 점검 등의 후속 단계와 바로 연결된다.

# Machine Learning

## 6. CSV 로드 → 피처/타깃 지정 → 라벨 불균형 점검(보조 라벨) → 학습/테스트 분할
이 단계는 학습 입력과 타깃을 확정하고, 분류 타깃의 불균형을 완화해 안정적인 평가가 가능하도록 데이터를 준비한다. 먼저 dataset.csv를 읽어 입력 피처 7개($U$, $T_{in}$, $T_{amb}$, $E_{25}$, $β$, $α$, $h_o$)와 회귀 타깃(max_vm), 분류 타깃(pass)을 지정한다. 이어 분류 타깃의 클래스 분포를 점검해 한쪽 클래스만 존재하거나 소수 클래스가 20개 미만이면 실제 분류 실습이 불안정하므로, 보조 라벨(pass_median) 을 생성한다. 보조 라벨은 회귀 타깃 max_vm의 중앙값을 기준 임계치로 두어 max_vm <= median 이면 1, 그 외 0으로 정의해 양/음 비율을 균형에 가깝게 만든다(이상적인 구현은 훈련 세트에서 계산한 중앙값을 임계치로 사용해 데이터 누설을 더욱 줄이는 것). 마지막으로 입력 X, 회귀 y_r, 분류 y_c를 구성하고, train_test_split(stratify=y_c) 로 80/20 분할을 수행한다. stratify 옵션은 학습/테스트 양쪽에 동일한 클래스 비율을 보장해, 불균형에 따른 평가 편차를 줄인다. 결과적으로 이 단계는 회귀와 분류 모두에 대해 일관된 입력/타깃 정의, 불균형 방지 장치, 재현 가능한 분할(random_state=42)을 한 번에 수행하여 이후 모델 학습(7~8단계)과 교차검증이 신뢰성 있게 진행되도록 기반을 마련한다

## 7. 회귀 베이스라인 학습/평가
이 단계는 max_vm(회귀 타깃)을 예측하기 위한 기본 회귀 모델들을 한 번에 학습하고 비교한다. 먼저 KFold(n_splits=5, shuffle=True, random_state=42)로 교차검증 분할자를 만들고, 모든 모델은 파이프라인을 통해 입력 표준화(StandardScaler)를 선행하여 데이터 누설을 방지한다(스케일러는 훈련 fold에서만 fit, 검증/테스트에는 transform만 적용). 비교 대상은 (1) LinearRegression 파이프라인, (2) Ridge 회귀의 하이퍼파라미터 alpha를 GridSearchCV로 탐색하는 파이프라인, (3) RandomForestRegressor의 n_estimators, max_depth, min_samples_leaf를 그리드로 탐색하는 구성이다. 각 모델은 훈련 세트로 학습 후 테스트 세트에서 예측을 수행하고, 평가 지표는 RMSE(작을수록 좋음)와 R2(클수록 좋음, 음수면 기준선보다 나쁨)를 사용한다. GridSearchCV 객체의 경우 .fit()이 끝나면 내부적으로 최적 하이퍼파라미터로 전체 훈련 세트를 재학습하므로, 이후 .predict()는 최적 모델을 사용한다. 또한 best_params_를 함께 기록해 어떤 설정이 선택되었는지 투명하게 남긴다. 최종적으로 모델명, RMSE, R2, best_params를 DataFrame(reg_results)에 모아 한눈에 비교할 수 있도록 정리하며, 이 표는 이후 단계에서 최고 성능 회귀 모델 선 및 정합(Parity) 플롯(9번) 생성의 근거 자료가 된다.

## 8. 분류 베이스라인 학습/튜닝/평가
이 단계는 허용응력 기준의 합격/불합격 레이블을 예측하는 기본 분류기를 한 번에 학습하고 비교한다. 각 모델은 공정 비교와 누설 방지를 위해 동일한 분할(6단계)과 동일한 교차검증 설정(cv=KFold(5, shuffle=True, random_state=42))을 사용한다. 로지스틱 회귀(LogReg)는 StandardScaler를 포함한 파이프라인으로 감싸고 정규화 강도 C를 그리드로 탐색한다. 결정나무(DT)는 max_depth, min_samples_leaf를, 랜덤포레스트(RF)는 트리 수/깊이/리프 최소샘플을 그리드로 탐색한다. 모든 모델은 GridSearchCV로 최적 하이퍼파라미터를 찾은 뒤 그 설정으로 전체 학습 세트를 재학습해 테스트셋을 예측한다. 평가는 정확도(ACC), 불균형에 강한 F1, 확률 기반 판별력을 보는 ROC-AUC로 수행한다. ROC-AUC는 가능하면 predict_proba의 양성(1) 확률을, 없으면 decision_function 출력을 사용하며, 후자는 단조성만 유지되면 되므로 0-1 min-max로 스케일해도 AUC 해석에 문제가 없다. 결과를 표로 정리한 뒤 F1→AUC 우선 정렬로 최상 모델을 고르고, 혼동행렬과 classification_report로 오탐/미탐 구조를 구체적으로 해석한다(예: 실제 불합격 중 합격으로 본 개수 등). 운영 목적이 미검출 최소화라면, 선택한 모델의 확률 출력에 대해 임계값을 0.5에서 조정하여 프리시전-리콜 트레이드오프를 맞추는 것을 권장한다. 트리/포레스트는 feature_importances_로 입력 변수 영향도를 간단히 확인할 수 있고, 로지스틱은 계수 부호로 해석 가능해 원인 분석에 유용하다.

## 9. 랜덤포레스트 중요도 시각화 및 회귀 정합 플롯
이 단계는 모델이 무엇을 보고 예측하는지, 그리고 예측이 실제 값과 얼마나 일치하는지를 빠르게 진단한다. 먼저 회귀/분류 각각의 RandomForest에서 feature_importances_를 꺼내 막대그래프로 표시해, 입력 변수 ($U$, $T_{in}$, $T_{amb}$, $E_{25}$, $β$, $α$, $h_o$) 중 영향력이 큰 순서를 확인한다. 이는 설계 변수 조정의 우선순위를 정하거나, 데이터 수집/감지 센서의 중요도를 판단하는 근거가 된다. 다음으로 회귀 탑 성능 모델(예: RF-GS)을 선택해 테스트셋에서 예측값과 정답을 산점도(Parity plot)로 비교한다. 점들이 대각선(y=x) 부근에 모이면 정합이 좋고, 체계적인 곡률이나 꼬리 부분의 편차가 보이면 비선형성 미모델링, 데이터 범위 바깥 예측, 타깃 스케일 이슈 등을 의심할 수 있다. 이 플롯은 RMSE/R2 같은 단일 수치가 놓치기 쉬운 오류 패턴(언더/오버 예측 영역, 극값 왜곡)을 시각적으로 드러내며, 후속으로 모델 교체(예: 더 깊은 트리, 추가 특성), 입력 스케일 조정, 이상치 점검 등의 개선 방향을 결정하는 데 유용하다.

# PyTorch Surrogate Training

## 10. MLP 서로게이트(수동 SGD) 학습/평가
이 단계는 PyTorch로 간단한 MLP(2×128 ReLU)를 학습해 물리 라벨 max_vm을 빠르게 예측하는 서로게이트를 만든다. 먼저 입력을 StandardScaler로 표준화하고, 타깃은 $log_{10}$ 변환해 스케일을 안정화한다. torch.optim을 쓰지 않고 순수 SGD 스텝을 직접 구현해(grad 계산 → L2 weight decay 더하기 → 파라미터 갱신) 라이브러리 의존 이슈를 회피하면서도 동작을 유지한다. 학습은 미니배치, MSE 손실(로그공간), 검증 MSE 모니터링, 조기 종료(patience)로 구성된다. 에폭마다 train/val 손실을 기록해 수렴과 과적합을 시각화하고, 최저 검증 손실 시점의 가중치를 best_state로 저장해 복원한다. 평가 시에는 예측($log_{10}$)을 원공간으로 되돌려 Pa 단위 RMSE를 보고하고, Parity plot(정답 vs 예측)을 통해 전 구간 정합을 직관적으로 확인한다. 이 서로게이트는 이후 시간 시나리오에서 $σ(t)$를 반복 예측해야 하는 피로 분석 단계의 핵심 가속기이며, 성능이 부족하면 은닉 크기/층 수 증가, 학습률 조정, 드롭아웃/배치정규화 추가, 더 긴 학습 또는 데이터 확장으로 개선할 수 있다.

# Sensitivity Analysis

## 11. MLP 민감도/탄력도 진단(입력→예측 영향 분석)
이 단계는 학습된 MLP가 예측하는 로그응력 $y=log_{10}(σ)$에 대해 각 입력 피처가 얼마나 민감하게 작용하는지 국소 기울기($gradient$) 로 정량화한다. 먼저 표준화된 입력 공간(z)에서 $\dfrac{\mathrm{d}log_{10}(σ)}{\mathrm{d}z}$를 자동미분으로 계산해, 절댓값 평균과 표준편차로 평균 민감도(±분산) 를 막대그래프로 시각화한다. 표준화 좌표 민감도는 모델이 “스케일링을 걷어낸 공정 비교”에서 어떤 변수를 더 의존하는지 보여준다. 다음으로 스케일러의 분산을 되돌려 $\dfrac{\mathrm{d}log_{10}(σ)}{\mathrm{d}x}$(원단위)로 환산하고, 더 나아가 체인룰을 통해 응력 단위 민감도 $\dfrac{\mathrm{d}σ}{\mathrm{d}x}$ $(Pa per unit)$ 를 구해, 설계 변수의 1 단위 변화가 절대 응력에 미치는 영향을 직관적으로 확인한다. 마지막으로 


(x/σ)*(dσ/dx)를 사용해 탄력도 |∂logσ/∂logx| 를 산출한다. 탄력도는 “x가 %만큼 변하면 $σ$가 몇 % 반응하는가”를 나타내므로 단위와 스케일에 무관한 비교가 가능하다. 모든 지표는 여러 샘플을 무작위로 뽑아(예: $n=256$) 평균±표준편차로 요약하여 지역적 편차도 함께 본다. 해석 팁: 표준화 민감도는 모델 내부의 상대적 의존도를, $\dfrac{\mathrm{d}σ}{\mathrm{d}x}$는 절대 하중 기여도를, 탄력도는 운영 퍼센트 변화 대비 응력 퍼센트 변화를 보여준다. 값이 큰 입력은 모델과 물리 모두에서 중요한 조절 레버일 가능성이 높으며, 데이터 수집 정밀도(센서 정확도)와 운전 제어 우선순위를 정하는 근거가 된다. 단, 이는 선형 근사(국소) 이므로 큰 변화나 학습 분포 밖에서는 해석을 보수적으로 적용해야 한다.

## 12. 유한차분(FD) vs 자동미분(grad) 일치성 점검
이 단계는 11번에서 사용한 민감도/탄력도 계산이 정확하고 스케일 변환과 일관되는지 검증한다. (1) 표준화된 학습 입력 Xtr에서 일부 샘플을 고르고, (2) 이를 원단위로 되돌린 X0_orig 주변에서 각 피처를 +1%만큼 곱해 작은 교란을 준다($\epsilon=0.01$). (3) 모델 출력 y=log10(σ)의 변화를 이용해 유한차분 탄력도 elas_fd = Δlog10σ / Δlog10x 를 계산한다. 동시에 같은 샘플에 대해 자동미분으로 d(log10σ)/dz를 구해 스케일러 분산을 반영하여 d(log10σ)/dx로 환산하고, elas_grad = ln(10) * (x * d(log10σ)/dx) 로 그래디언트 기반 탄력도를 얻는다. 마지막으로 각 피처별로 FD 평균과 grad 평균을 나란히 출력한다. 두 값이 근접하면(예: 절대차가 매우 작거나, 상대오차 수 % 이내) 모델의 자동미분 경로, 스케일 역변환, 탄력도 정의가 제대로 구현되었음을 뜻한다. 큰 오차가 보이면 (a) 스케일러 적용 위치/축, (b) 로그 기반 체인룰의 ln(10) 계수, (c) 표준화/원단위 혼용, (d) 너무 큰 eps로 인한 비선형 영향 등을 점검해야 한다. 이 검증 셀을 통과하면 이후 민감도 해석(현장 제어 레버 선정, 센서 정밀도 요구 도출)에 신뢰도를 부여할 수 있다.

# Thermal-stress Simulation and Fatigue Assessment

## 13. 피로 해석 기반 함수: 레인플로우, ε–N 수명, 온도 시나리오
이 단계는 시간에 따라 변하는 운전 조건에서 고무 링의 피로 손상을 계산하기 위한 공용 유틸을 한 곳에 모은다. 먼저 _turning_points(y, eps)가 시계열에서 평탄 구간을 제거하고 기울기 부호가 바뀌는 지점만 남겨 노이즈로 인한 과대 계수를 줄인다(eps는 절대값 컷). 그런 다음 rainflow(series, eps)가 ASTM 스타일로 반주기(0.5)와 전주기(1.0)를 세어 (range, mean, count) 배열을 만든다. 핵심 함수 miner_from_strain_eN(sigma_series, T_in_series, const_params, eps0, b, rf_eps, eps_e)는 서로게이트 예측 응력 sigma(t)와 온도 T_in(t)로부터 온도의존 탄성계수 E(T)=E25*exp(-beta*(T-25))를 계산해 변형률 eps(t)=sigma/E(T)를 만든 뒤, 레인플로우로 얻은 진폭 eps_a에 대해 고무용 ε–N 관계 Nf=(eps0/eps_a)^b를 적용한다. 피로한계 eps_e(진폭 컷)를 두면 그보다 작은 사이클은 손상에서 제외되고, Miner 합산 D=sum(count/Nf)로 누적 손상을 반환한다(D≈1을 한계로 해석). 마지막으로 scenario_noise(...)는 평균 Tm 주위의 랜덤 온도 파형(선택적 1차 스무딩)을 생성하고, 동시에 유동/재료 상수(U, T_amb, E25, β, α, h_o)를 묶어 후속 계산과 바로 호환되게 한다. 정리하면 13번은 온도 시나리오 생성 → ε(t) 추출 → 레인플로우 계수 → ε–N 수명 → Miner 손상의 전체 피로 파이프라인을 모듈화해, 이후 단계에서 손쉽게 수명 평가와 파라미터 튜닝을 반복할 수 있게 해준다.

## 14. 시간 시나리오 → 서로게이트로 σ(t) 예측
이 함수는 시간에 따라 변하는 inlet temperature $T_{in}(t)$ 시퀀스를 받아, 10단계에서 학습한 MLP surrogate로 각 시점의 최대 등가응력 $\sigma(t)$를 예측한다. 먼저 const_params 딕셔너리의 고정 조건들($U$, $T_{in}$, $T_{amb}$, $E_{25}$, $β$, $α$, $h_o$)을 모든 시점에 복제하고, 시간에 따라 변하는 항목만 $T_{in}(t)$로 채워 입력 행렬 X를 만든다. 그런 다음 10단계에서 fit한 입력 스케일러로 X를 변환하고, 모델을 eval + no_grad 모드로 추론해 $y_log = log_{10}(\hat{\sigma})$를 얻는다. 예측이 훈련 분포 밖으로 튈 때 수치 에러 나 비현실적 외삽을 줄이기 위해, 학습 타깃의 0.5 ~ 99.5% 범위를 기준으로 tanh 기반 soft clamp를 적용한 뒤 10**y_soft 로 sigma(t)를 복원한다. 반환값은 길이가 $len(T_in)$인 1D numpy 배열이며, 15~16단계에서 rainflow -> e-N -> Miner 손상 및 수명 계산에 바로 사용된다.

## 15. 변형률 진단: 시나리오 생성 → sigma(t) 예측 → eps(t) 분석(통계/플롯)

이 단계는 실제 운전과 비슷한 온도 변동이 있을 때 고무 링에 걸리는 변형률을 정량적으로 진단한다. 먼저 scenario_noise로 2초 간격, 총 6시간짜리 $T_{in}(t)$ 시나리오를 만들고(평균 80 degC, +-5 degC, 1차 스무딩 60 s), 10단계에서 학습한 MLP 서로게이트로 각 시점의 등가응력 $sigma(t)$를 예측한다. 기록 길이 record_hours_N = len(tN)DT_S/3600.0 로 계산해 이후 수명 외삽의 기준으로도 쓸 수 있다. 다음으로 온도의존 탄성계수 $E(T)=E_{25}\exp\(-\beta\(T-25))$를 사용해 eps(t) = sigma(t)/E(T)를 구한다. eps(t)를 rainflow에 넣어 사이클별 진폭 eps_a, 개수(count)를 얻고, 요약 통계(min, median, max, p01, p05, p10, p90, p95)를 출력해 변형률 분포를 수치로 확인한다. 특히 피로한계 후보 eps_e를 바로 잡을 수 있도록 세 가지 권장값을 함께 제시한다: conservative(하위 10% 커트), typical(중앙값의 50%), loose(중앙값의 25%). 마지막으로 세 가지 플롯을 제공한다. (1) 시간 대비 $T_{in}(t)$ 파형, (2) 시간 대비 eps(t) [%] 파형, (3) rainflow로 얻은 eps_a[%] 히스토그램(가중치=사이클 수). 히스토그램 x축은 실제 데이터 상단 구간 낭비를 줄이기 위해 0~min(0.04, max(eps_a_pct))로 제한하고, 미세한 분포를 보려 bins를 1000개로 설정했다. 

# Life Prediction

## 16. ε–N 수명 계산 함수: sigma(t) → ε(t) → 레인플로우 → Miner 손상 → 수명[h]

이 함수는 시간축 t와 온도 $T_{in}(t)$, 서로게이트가 예측한 응력 $sigma(t)$, 재료 상수(const의 E25, beta)를 받아 ε–N 모델로 누적손상 D와 예상 수명 life_hours를 계산한다. 절차는 ① 온도의존 탄성계수 E(T)=E25*exp(-beta*(T-25))로 순간 변형률 시계열 eps_t = sigma/E(T)를 만든다. ② 변형률 파형을 rainflow에 넣어 사이클별 진폭 eps_a와 개수 cnt를 얻는다. ③ 피로한계 eps_e(진폭 컷) 이상만 선택해 ε–N 관계 Nf = (eps0/eps_a)^b로 사이클당 허용 반복수를 계산하고, ④ Miner 합산 D = Σ(cnt/Nf)로 누적손상을 구한다. ⑤ 기록 길이(시나리오 길이)를 record_hours로 환산한 뒤, 수명[h] ≈ record_hours / D 로 외삽한다(분모 0 방지를 위해 작은 하한 사용). 입력 파라미터 의미: eps0(기준 변형률), b(지수), eps_e(피로한계), rf_eps(레인플로우용 미세노이즈 컷). 반환값은 (life_hours, D, record_hours, rf, eps_t, eps_a, cnt)로, 수명과 손상뿐 아니라 중간 산물(레인플로우 결과, 변형률 시계열/진폭, 사이클 수)까지 함께 제공해 결과 해석과 파라미터 튜닝(EPS0, b, EPS_E 재조정)에 바로 활용할 수 있다.

## 17. e–N 기반 손상/수명 계산(요약 실행)

이 단계는 앞에서 준비한 시나리오(tN, TinN, constN), 서로게이트 응력 시계열(sigmaN), 그리고 16번의 함수 compute_life_eN_from_sigma를 그대로 호출해 누적손상 D와 예상 수명 life_hours를 한 번에 산출한다. 입력 파라미터 EPS0(기준 변형률), B(지수), EPS_E(피로한계 진폭)는 고무 피로 특성에 직접 연결되므로 결과에 큰 영향을 준다. 함수 내부에서는 E(T)로부터 변형률 eps(t)을 만들고, rainflow로 사이클 진폭 eps_a를 계수한 뒤, e–N 관계 Nf=(EPS0/eps_a)^B와 Miner 합산으로 D를 계산한다. 출력 로그는 (1) sigmaN의 분포 요약(min, max, std), (2) 기록 길이 record_hours, (3) 손상 D와 외삽 수명 life_hours를 보여준다. 해석 팁: D 약 1이 설계 한계, life_hours는 record_hours를 D로 나눈 외삽치이며, EPS_E를 높이면 미세 사이클이 무시되어 수명이 길어지고, 반대로 낮추면 더 보수적 결과가 나온다.






