# MAT3123
MAT3123-Final Project

Final 프로젝트의 목표는 속이 빈 고무 패킹의 열–기계 거동을 물리식으로 라벨링해 합성 데이터셋을 만들고, 이를 학습한 MLP서로게이트로 온도 변동 시나리오에서 응력 기반 $ε-N$ 피로수명을 빠르게 예측한다.

1. Data Setting (1~5)
2. Machine Learning (6~9)
3. PyTorch Surrogate Training (10)
4. Sensitivity Analysis (11~12)
5. Thermal-stress Simulation and Fatigue Assessment (13~15)
6. Life Prediction (16~17)
17개의 코드셀로 이루어져 있다.

# Data Setting
## 1. 노트북 환경 체크 + 그래프 기본 설정
Python, Numpy, Pandas의 버전을 확인하고 그래프의 설정값을 조절한다.

## 2. 내부 대류 열전달 계수 h
이 단계에서는 관 내 유동의 내부 대류 열전달계수 $h$를 계산해 이후 온도장 및 응력 해석의 경계조건으로 사용한다. 

먼저 $20\text{–}80~^\circ\mathrm{C}$ 범위에서 물의 평균 물성치(열전도도 $k$, 점도 $\mu$, 밀도 $\rho$, 비열 $c_p$, Prandtl 수 $\mathrm{Pr}$)를 정의한다. 

유속 $U$와 관내경 $D_i$로 Reynolds 수를 $\mathrm{Re}=\dfrac{{\rho}UD_i}{\mu}$ 로 계산하고, 유동 상태를 판별한다. 

층류 $(\mathrm{Re}<2300)$ 에서는 완전발달 내부유동 가정으로 $\mathrm{Nu}=3.66$ 을 사용한다. 

난류 $(\mathrm{Re}\ge 2300)$ 에서는 Dittus–Boelter 상관식 $\mathrm{Nu}=0.023\mathrm{Re}^{0.8}\mathrm{Pr}^{n}$ 을 쓰며, 가열은 $n=0.4$, 냉각은 $n=0.3$ 을 사용한다. 

마지막으로 $h=\dfrac{\mathrm{Nu}k}{D_i}$ 로 환산한다. 

해당 근사는 원형 관, 매끈한 벽, 충분히 긴 관, 상수 물성 등의 단순화를 포함하므로, 고온/점도 변화가 큰 경우나 비원형 덕트, 입구영향이 큰 짧은 관에서는 보정 또는 다른 상관식 검토가 필요하다.


## 3. 고무 링의 온도 분포 T(r)
이 단계는 속 빈 원통(고무 링)의 반지름 방향 정상상태 온도분포 $T(r)$를 구한다. 

축대칭, 축방향 열흐름 무시, 고체 내부 생성열을 $0$, 열전도도 $k$ 일정 가정에서 지배식은 $\dfrac{\mathrm{d}}{\mathrm{d}r}\left(r\dfrac{\mathrm{d}T}{\mathrm{d}r}\right)=0$ 이고 해는 $T(r)=C1ln(r)+C2$ 이다. 

내부/외부 표면에는 대류 경계가 적용된다: $r=r_i$ 에서 $-k\dfrac{\mathrm{d}T}{\mathrm{d}r}=h_i(T-T_{i,\infty})$, $r=r_o$ 에서 $-k\dfrac{\mathrm{d}T}{\mathrm{d}r}=h_o(T-T_{o,\infty})$.

이를 C1, C2에 대한 선형 2x2 방정식으로 정리해 행렬 $M \cdot [C1  C2]^T = rhs$ 를 만들고, $numpy$ 선형해법으로 $C1$, $C2$ 를 푼다. 

그런 다음 $r_i~r_o$ 사이를 균일 격자로 샘플링해 $T(r)=C1ln(r)+C2$ 값을 계산해 반환한다. 

출력은 반지름 벡터 $r[m]$와 온도 벡터 $T[^\circ\mathrm{C}]$ 이며, 이 분포는 이후 열팽창 변형률 및 응력 근사 계산의 입력으로 사용된다. 

가정상 $k$ 와 물성은 상수이고, 복사나 비선형 효과는 무시한다.

## 4. 온도→물성/열팽창→응력(근사) 라벨러
이 단계는 주어진 운전/재료 조건에서 고무 링의 최대 등가응력과 합격/불합격 라벨을 자동 생성하는 핵심 라벨러다. 

먼저 평균 온도 $T_{avg}$로 온도의존 등가 탄성계수 $E(T)=E_{25}\exp\(-\beta\(T-25))$를 계산한다. 

이어 고무의 선형 열팽창 계수 $\alpha$와 기준온도 $T_{ref}$를 사용해 열팽창 변형률 분포 $ε_{th}(r)=\alpha\(T(r)-T_{ref})$을 얻는다. 

구조 거동은 단순화하여 둘레방향 변형이 거의 $0$으로 억제된다고 가정하고, 열팽창에 역행하는 기계 변형을 $ε_{mech}=-ε_{th}$로 두어 원주방향 응력을 $\sigma_\theta=\dfrac{E}{1-\nu}\cdot\varepsilon_{\mathrm{mech}}$ 로 근사한다. 

이 분포의 절댓값 최대치를 최대 등가응력(보수적 von Mises 근사)으로 사용한다. 

label_one_sample은 다음 순서로 동작한다: 

(1) 유속 $U$, 내경 $D_i$로 내부 대류계수 $h_i$ 계산 → (2) 내부/외부 대류 경계와 고무 열전도율 $k$로 속 빈 원통의 정상상태 온도장 $T(r)$ 해석 → (3) $T_{avg}$로 $E$ 산출 → (4) $ε_{th}(r)$ 계산 → (5) $σ_θ(r)$ 와 그 최대치 max_vm 산출 → (6) 허용응력 $σ_{allow}$와 비교해 pass_flag를 $1$과 $0$으로 부여

반환에는 $r$, $T(r)$, $E$, $ε_{th}(r)$, $σ_θ(r)$, max_vm, pass_flag, $h_i$가 포함되어 이후 데이터셋 생성과 모델 학습에 바로 쓸 수 있다. 

이때, 선형 탄성, 등방 열팽창, $ν≈0.49$, 정상상태 열전달, 접촉/구속 단순화 등을 가정한다.

## 5. 랜덤 데이터셋 생성 + 빠른 확인용 플롯
이 단계는 학습에 사용할 표준화된 테이블 데이터를 자동 생성한다. 

먼저 난수 시드로 재현성을 확보한 뒤, 운전/재료 변수($U$, $T_{in}$, $T_{amb}$, $E_{25}$, $β$, $α$, $h_o$)를 현실 범위에서 균일 샘플링한다. 

각 샘플마다 물리 라벨러를 호출해 최대 등가응력 max_vm(회귀 타깃)과 허용응력 기준 pass(분류 타깃)를 계산하고, 이를 하나의 표(df)에 쌓아 CSV로 저장한다. 

생성된 df.head()와 describe()를 통해 분포와 스케일을 즉시 점검하며, 컬럼은 입력 7개($U$, $T_{in}$, $T_{amb}$, $E_{25}$, $β$, $α$, $h_o$)와 출력 2개(max_vm, pass)로 명확히 분리된다. 

이어 개별 프로파일들의 평균이 아니라 평균 파라미터에서 단일 해석을 수행해, 평균 조건에서의 반지름 방향 온도 $T(r)$와 근사 hoop 응력 분포를 플롯하여 물리적으로 가능한지 시각적으로 검증한다. 

마지막으로 데이터셋 합격률(pass_rate)과 평균 조건의 내부 대류계수 $h_i$, max_vm을 함께 출력해 기준을 잡는다. 

이 산출물은 이후 scikit-learn/PyTorch에 그대로 투입할 수 있는 깔끔한 입력-타깃 테이블이며, 학습/검증 분할, 스케일링, 라벨 균형 점검 등의 후속 단계와 연결된다.

# Machine Learning

## 6. CSV 로드 → 피처/타깃 지정 → 라벨 불균형 점검(보조 라벨) → 학습/테스트 분할
이 단계는 학습 입력과 타깃을 확정하고, 분류 타깃의 불균형을 완화해 안정적인 평가가 가능하도록 데이터를 준비한다. 

먼저 dataset.csv를 읽어 입력 피처 7개($U$, $T_{in}$, $T_{amb}$, $E_{25}$, $β$, $α$, $h_o$)와 회귀 타깃(max_vm), 분류 타깃(pass)을 지정한다. 

이어 분류 타깃의 클래스 분포를 점검해 한쪽 클래스만 존재하거나 소수 클래스가 20개 미만이면 실제 분류 실습이 불안정하므로, 보조 라벨(pass_median) 을 생성한다. 

보조 라벨은 회귀 타깃 max_vm의 중앙값을 기준 임계치로 두어 max_vm <= median 이면 1, 그 외 0으로 정의해 양/음 비율을 균형에 가깝게 만든다(이상적인 구현은 훈련 세트에서 계산한 중앙값을 임계치로 사용해 데이터 누설을 더욱 줄이는 것) 

마지막으로 입력 $X$, 회귀 $y_r$, 분류 $y_c$를 구성하고, train_test_split(stratify= $y_c$) 로 80/20 분할을 수행한다. 

stratify 옵션은 학습/테스트 양쪽에 동일한 클래스 비율을 보장해, 불균형에 따른 평가 편차를 줄인다. 

결과적으로 이 단계는 회귀와 분류 모두에 대해 일관된 입력/타깃 정의, 불균형 방지 장치, 재현 가능한 분할(random_state=42)을 한 번에 수행하여 이후 모델 학습과 교차검증이 신뢰성 있게 진행되도록 기반을 마련한다

## 7. 회귀 베이스라인 학습/평가
이 단계는 max_vm(회귀 타깃)을 예측하기 위한 기본 회귀 모델들을 한 번에 학습하고 비교한다. 

먼저 KFold(n_splits=5, shuffle=True, random_state=42)로 교차검증 분할자를 만들고, 선형 회귀와 릿지 회귀는 파이프라인에서 StandardScaler로 입력을 표준화하여 데이터 누설을 방지한다.

스케일러는 훈련 fold에서만 fit, 검증/테스트에는 transform만 적용하고, RandomForestRegressor는 트리 기반이라 별도의 스케일링이 필요 없어 파이프라인 없이 사용한다.

비교 대상은 (1) LinearRegression 파이프라인, (2) Ridge 회귀의 하이퍼파라미터 alpha를 GridSearchCV로 탐색하는 파이프라인, (3) RandomForestRegressor의 n_estimators, max_depth, min_samples_leaf를 그리드로 탐색하는 구성이다. 

GridSearchCV의 기본 평가지표는 R²이므로, 내부 교차검증에서는 R²가 최대가 되는 설정이 선택된다.

각 모델은 훈련 세트로 학습 후 테스트 세트에서 예측을 수행하고, 평가 지표는 RMSE(작을수록 좋음)와 R²(클수록 좋음, 음수면 기준선보다 나쁨)를 사용한다. 

GridSearchCV 객체의 경우 .fit()이 끝나면 내부적으로 최적 하이퍼파라미터로 전체 훈련 세트를 재학습하므로, 이후 .predict()는 최적 모델을 사용한다. 

또한 best_params_를 함께 기록해 어떤 설정이 선택되었는지 남긴다. 

최종적으로 모델명, RMSE, R², best_params를 DataFrame(reg_results)에 모아 한눈에 비교할 수 있도록 정리하며, 이 표는 이후 단계에서 최고 성능 회귀 모델 선 및 정합(Parity) 플롯 생성의 근거 자료가 된다.

## 8. 분류 베이스라인 학습/튜닝/평가
이 단계는 허용응력 기준의 합격/불합격 레이블을 예측하는 기본 분류기를 한 번에 학습하고 비교한다. 

각 모델은 공정 비교와 누설 방지를 위해 동일한 분할과 동일한 교차검증 설정(cv=KFold(5, shuffle=True, random_state=42))을 사용한다. 

로지스틱 회귀(LogReg)는 StandardScaler → LogisticRegression 파이프라인으로 감싸 감싸 입력 스케일을 표준화하고 정규화 강도 C를 그리드로 탐색한다. 

결정나무(DT)는 max_depth, min_samples_leaf를, 랜덤포레스트(RF)는 n_estimators, max_depth, min_samples_leaf를 그리드로 탐색한다. 

모든 모델은 GridSearchCV로 하이퍼파라미터를 튜닝하며, scoring을 따로 지정하지 않았으므로 내부 CV의 선택 기준은 정확도(ACC)다. 즉, ACC를 최대화하는 설정이 고른 뒤, 그 최적 설정으로 전체 훈련 세트를 재학습하고 테스트셋을 예측한다.

평가는 정확도(ACC), 불균형에 강한 F1, 확률 기반 판별력을 보는 ROC-AUC로 수행한다. 

ROC-AUC는 가능하면 predict_proba의 양성(1) 확률을, 없으면 decision_function 출력을 사용하며, 후자는 단조성만 유지되면 되므로 0-1 min-max로 스케일해도 AUC 해석에 문제가 없다. 

결과를 표로 정리한 뒤 F1 → AUC 우선 정렬로 최상 모델을 고르고, 혼동행렬과 classification_report로 오탐/미탐 구조를 구체적으로 해석한다(예: 실제 불합격 중 합격으로 본 개수 등). 운영 목적이 미검출 최소화라면, 선택한 모델의 확률 출력에 대해 임계값을 0.5에서 조정하여 Precision–Recall 트레이드오프를 맞추는 것을 권장한다. 

트리/포레스트는 feature_importances_로 입력 변수 영향도를 간단히 확인할 수 있고, 로지스틱은 계수 부호로 해석 가능해 원인 분석에 유용하다.

## 9. 랜덤포레스트 중요도 시각화 및 회귀 정합 플롯
이 단계는 모델이 어떤 입력 변수에 주로 의존해 예측하는지, 그리고 예측이 실제 값과 얼마나 일치하는지를 시각적으로 진단한다.

먼저 회귀·분류 각각의 RandomForest에서 feature_importances_를 추출해 막대그래프로 표시한다.

이는 각 입력 변수($U$, $T_{in}$, $T_{amb}$, $E_{25}$, $β$, $α$, $h_o$)가 트리 분할 시 불순도(회귀에서는 MSE, 분류에서는 지니/엔트로피) 감소에 기여한 상대적 중요도를 나타낸다.

중요도가 높을수록 해당 피처가 모델의 의사결정에 크게 기여했음을 의미하며, 해당 결과는 설계 변수 조정의 우선순위를 정하거나, 데이터 수집·센서 배치의 중요도를 판단하는 근거가 된다.

단, 이 중요도는 불순도 기반 상대 지표이므로, 피처 간 상관성이나 스케일 차이에 따라 가중이 분산될 수 있다는 점을 염두에 두어야 한다.

다음으로 회귀 결과표에서 선택된 모델(기본적으로 첫 번째 항목 예: RF-GS)을 사용해 테스트셋에서 예측값과 실제값을 산점도(Parity plot) 로 비교한다.
 
점들이 대각선(y=x) 부근에 모이면 정합이 좋고, 체계적인 곡률이나 꼬리 부분의 편차가 보이면 비선형성 미모델링, 데이터 범위 바깥 예측, 타깃 스케일 이슈 등을 의심할 수 있다. 

이 플롯은 RMSE/R² 같은 단일 수치가 놓치기 쉬운 오류 패턴(언더/오버 예측 영역, 극값 왜곡)을 시각적으로 드러내며, 후속으로 모델 교체(예: 더 깊은 트리, 비선형 회귀), 입력 스케일 조정, 이상치 제거 또는 데이터 재가중 등 개선 방향을 정하는 데 유용한 시각적 진단 도구로 활용된다.

# PyTorch Surrogate Training

## 10. MLP 서로게이트(수동 SGD) 학습/평가
이 단계는 PyTorch로 간단한 MLP(2×128 ReLU)구조를 학습해 물리 라벨 max_vm(최대 등가응력)을 빠르게 예측하는 서로게이트를 만든다. 


먼저 입력 변수는 StandardScaler로 표준화(평균 $0$, 분산 $1$) 하고, 타깃은 $\log_{10}$ 변환으로 스케일안정화해 극값의 영향을 완화한다.

이 변환은 MSE 손실 계산 시 큰 값의 오차가 과도하게 반영되는 문제를 줄이고, 신경망의 수렴 안정성을 높인다.

torch.optim을 쓰지 않고 순수 SGD 스텝을 직접 구현해 각 epoch마다 loss.backward()로 기울기를 계산하고, 모든 파라미터에 대해 L2 weight를 더해 적용한 뒤 갱신한다.

이 과정을 통해 라이브러리 의존성을 최소화하면서도 SGD 기반의 정상적인 학습 과정을 재현한다.

학습은 미니배치(Mini-batch)방식으로 수행되며, 손실함수는 MSE(로그공간) 이다.

또한 검증 손실(val_mse)을 모니터링하며 조기 종료(patience=80) 를 적용해 과적합을 방지한다.

매 epoch마다 train/val 손실을 기록하여 학습 곡선을 그리고, 검증 손실이 최소일 때의 가중치를 best_state로 저장해 복원한다.

학습이 완료되면, 예측값 $log_{10}\hat{y}$을 원공간으로 되돌려 $y=10^{log_{10}\hat{y}}$로 변환하고, 테스트셋에서의 RMSE(단위: Pa) 를 계산해 최종 성능을 보고한다.

이와 함께 Parity plot(정답 vs 예측) 을 통해 예측값이 실제값과 얼마나 일치하는지를 시각적으로 확인한다.

점들이 대각선(y=x) 근처에 밀집할수록 전반 정합이 양호하며, 곡률·꼬리 쏠림이 있으면 비선형 미모델링 또는 외삽 영역의 오차 가능성을 의미한다.

이 MLP 서로게이트는 이후 시간 기반 피로 분석 단계에서 $σ(t)$를 반복적으로 예측해야 하는 핵심 가속기로 사용된다.

성능이 부족할 경우 은닉 크기 확대, 층 추가, 학습률 조정, 드롭아웃/배치정규화 추가, 더 긴 학습 혹은 데이터 확장 등을 통해 개선할 수 있다.

결과적으로 이 파이프라인은 입력 표준화 + 타깃 로그변환 + 수동 SGD + 조기 종료로 구성된
가볍고 안정적인 학습 루프이며, 로그공간 MSE → 원공간 RMSE로 연결되는 평가 절차를 통해
모델의 수렴과 물리적 정합성을 동시에 검증할 수 있다.

# Sensitivity Analysis

## 11. MLP 민감도/탄력도 진단(입력→예측 영향 분석)
이 단계는 학습된 MLP가 예측하는 로그응력 $y=log_{10}σ$에 대해 각 입력 피처가 모델 출력에 얼마나 민감하게 작용하는지 국소 기울기($gradient$) 로 정량화한다. 

먼저 표준화된 입력 공간(z)에서 $\dfrac{\partial(log_{10}σ)}{\partial z}$를 자동미분으로 계산한다.

여기서 $z$는 표준화된 입력이므로, 이 미분은 스케일 영향을 제거한 상대적 민감도를 나타낸다.

샘플 여러 개(예: $n=256$)를 무작위로 뽑아 각 피처별 절댓값 평균 및 표준편차를 계산하고, 막대그래프로 시각화하면 모델이 어떤 변수에 더 의존하는지를 직관적으로 확인할 수 있다.

다음으로 표준화 좌표를 원래 입력 단위로 되돌려 $\dfrac{\partial(log_{10}σ)}{\partial x} = \dfrac{1}{std(x)} \cdot \dfrac{\partial(log_{10}σ)}{\partial z}$ 를 얻는다.

이는 실제 물리 단위의 입력 변화가 로그 응력에 미치는 민감도를 의미한다.

또한 체인룰을 통해 응력 자체의 절대 민감도 $\dfrac{\partial σ}{\partial x} = (ln 10)\sigma \cdot \dfrac{\partial(log_{10}σ)}{\partial x}$ 를 계산하면, 각 설계변수가 1 단위 증가할 때 응력(단위: Pa) 가 얼마나 변하는지를 직접적으로 알 수 있으며, 이 값이 크면 그 변수의 변화가 실제 응력 수준에 큰 영향을 준다는 뜻이다.

마지막으로, 단위에 무관한 비교를 위해 탄력도(elasticity) $\left|\frac{\partial \log_{10}\sigma}{\partial \log_{10} x}\right| = \left|\frac{x}{\sigma}\frac{\partial \sigma}{\partial x}\right|$ 를 구한다.

탄력도는 “입력 x가 %만큼 변하면 응력 $σ$가 몇 % 변하는가”를 나타내므로 단위와 스케일에 무관한 모델의 구조적 민감도를 무차원 비율 형태로 보여준다.

이 모든 지표(표준화 민감도, 절대 민감도, 탄력도)는 무작위로 뽑은 여러 샘플에서 평균±표준편차로 계산해 지역적 분산도 함께 평가한다.

표준화 민감도는 모델 내부의 상대적 의존도를, 절대 민감도 $\dfrac{\partial σ}{\partial x}$는 입력 1 단위 변화가 절대 응력(Pa)에 미치는 물리적 영향을, 단위와 크기 차이를 제거한 비율 기반 반응성 (운전·제어 변수의 퍼센트 영향 비교)를 보여준다.

값이 큰 입력은 모델과 물리 모두에서 중요한 조절 레버일 가능성이 높으며, 데이터 수집 정밀도(센서 정확도)와 운전 제어 우선순위를 정하는 근거가 된다. 

단, 이는 선형 근사(국소) 이므로 입력이 큰 변화나 학습 분포 밖에서는 민감도 해석을 보수적으로 적용해야 한다.

## 12. 유한차분(FD) vs 자동미분(grad) 일치성 점검
이 단계는 사용한 민감도/탄력도 계산이 정확하고 스케일 변환과 일관되는지 검증하기위해 자동미분($gradient$)으로 얻은 탄력도와 유한차분($FD$)으로 근사한 탄력도를 비교 분석한다.

(1) 표준화된 학습 입력 Xtr 중 일부 샘플을 무작위로 선택하고  → (2) 이를 원단위로 되돌린 $X0(orig)$ 주변에서 각 피처를 +1%만큼 곱해 작은 교란을 준다($ε=0.01$) → (3) 모델 출력 $y=log_{10}(σ)$의 변화를 이용해 유한차분 탄력도 $Elasticity_{fd} = \dfrac{Δlog_{10}σ}{Δlog_{10}x} \approx \dfrac{y_1 - y_0}{log_{10}(1+\epsilon)}$ 를 계산한다. 이는 입력을 1%로 변화시켰을 때 로그응력이 얼마나 변하는지를 근사적으로 표현한다.

동시에 같은 샘플에 대해 자동미분으로 $\dfrac{\partial (log_{10}σ)}{\partial z}$를 구해 스케일러 분산을 반영하여 $\dfrac{\partial(log_{10}σ)}{\partial x} = \dfrac{1}{std(x)} \cdot \dfrac{\partial(log_{10}σ)}{\partial z}$ 로 환산한다.

해당 값을 이용해 ($gradient$) 기반의 탄력도 $\dfrac{\partial σ}{\partial x} = (ln 10)\sigma \cdot \dfrac{\partial(log_{10}σ)}{\partial x}$를 구한다.

마지막으로 각 피처별로 두 탄력도의 평균을 나란히 출력하여 비교한다.

하나는 수치근사(FD), 하나는 자동미분(grad)에 기반한 것으로, 두 값이 거의 일치하면(절대차가 매우 작거나 상대오차가 수% 이내) 자동미분 경로, 스케일러 역변환, 로그계수($ln10$) 처리, 체인룰 적용이 모두 올바르게 구현된 것이다.

만약 큰 오차가 보이면 (a) 표준화 스케일 적용 위치/축 오류, (b) 로그 기반 체인룰의 계수 누락, (c) 표준화/원단위 혼용, (d) 너무 큰 $ε$로 인한 비선형 영향 등을 점검해야 한다. 

이 검증 과정을 통과하면 앞선 민감도및 탄력도 분석에서 제시한 변수 중요도 결과가 수학적/구현적으로 일관됨을 보장하며, 이후 제어 변수 우선순위 선정및 센서 정밀도 평가 같은 민감도 응용 해석의 신뢰도를 확보할 수 있다.
# Thermal-stress Simulation and Fatigue Assessment

## 13. 피로 해석 기반 함수: 레인플로우, ε–N 수명, 온도 시나리오
이 단계는 시간에 따라 변하는 운전 조건에서 고무 링의 피로 손상 누적을 계산하기 위한 공용 유틸을 한 곳에 모은다. 

입력은 응력 시계열 $σ(t)$과 온도 시계열 $T_{in}(t)$, 출력은 $Miner$ 누적 손상값 $D$와 각 사이클별 진폭 및 수명 정보이다.

먼저 _turning_points(y, $ε$) 함수가 시계열에서 기울기 부호가 바뀌는 극값만 추출해 평탄 구간을 제거하고, $\epsilon$ 값(절대 차 컷오프)을 이용해 미세한 노이즈 요동을 제거한다. 이렇게 하면 불필요한 작은 사이클이 레인플로우 단계에서 중복 계산되는 문제를 방지할 수 있다.

다음으로 rainflow(series, $ε$)는 ASTM 규칙 기반의 레인플로우 사이클 계수 알고리즘을 구현한다. 턴닝 포인트 배열을 스택으로 처리하여 범위(range), 평균(mean), 카운트(count=1.0 또는 0.5)를 구한다. 이때 1.0은 완전주기, 0.5는 반주기를 의미하며 출력은 (range, mean, count)의 배열, 각 원소가 하나의 피로 사이클에 해당한다.

핵심 함수 miner_from_strain_eN($σ_{series}$, $T_{in, series}$, …)는 서로게이트가 예측한 응력 $σ(t)$과 입력 온도 $T_{in}(t)$을 이용해, 온도 의존 탄성계수 $E(T)=E_{25}\exp\(-\beta\(T-25))$를 계산하고 변형률 $ε(t) = \dfrac{\sigma(t)}{E(T)}$를 구한다.

그다음 레인플로우 결과에서 진폭 $ε_a = \dfrac{range}{2}$를 얻고, 고무용 $ε–N$ 관계식 $N_f=(\dfrac{ε_0}{ε_a})^b$으로 각 사이클의 수명을 계산한다.

피로한계 $ε_e$(진폭 컷)를 두면 그보다 작은 사이클은 손상에서 제외되고, $Miner$ 합산으로  $D=\Sigma \dfrac{count}{N_f}$로 누적 손상을 반환한다($D≈1$을 파손 한계로 해석)

마지막으로 함수 scenario_noise(...)는 온도 입력 시나리오 생성기로 평균 온도 $T_m$ 주위의 랜덤 온도 파형을 생성해 온도 시계열 $T_{in}(t)$를 만들고 선택적으로 1차 지연 필터(시간 상수 $τ_s$)를 적용해 완만한 변화를 모사한다.

동시에 유동 및 재료 상수($U$, $T_{amb}$, $E_{25}$, $β$, $α$, $h_o$)를 묶어 후속 계산과 바로 호환되게 한다. 

정리하면 해당 단계는 (1) 온도 시나리오 생성 → (2) 응력-변형률 변환 → (3) 레인플로우 주기 분석 → (4) $ε–N$ 수명 계산 → (5) $Miner$ 손상 누적으로 이어지는 피로 해석 전체 파이프라인의 핵심 구성요소를 정의하며, 이를 통해 서로게이트 응력 예측 결과를 실제 피로 수명 평가로 연결하는 기반을 마련한다.

## 14. 시간 시나리오 → 서로게이트로 σ(t) 예측
이 함수는 시간에 따라 변하는 유입온도 $T_{in}(t)$ 시퀀스를 받아, 이전 단계에서 학습한 MLP 서로게이트로 각 시점의 최대 등가응력 $\sigma(t)$를 예측한다. 

먼저 $const-params$ 딕셔너리의 고정 조건들($U$, $T_{amb}$, $E_{25}$, $β$, $α$, $h_o$)을 모든 시점에 복제하고, 시간에 따라 변하는 항목만 $T_{in}(t)$로 채워 입력 행렬 X를 만든다. 

그런 다음 학습 때 fit한 동일한 StandardScaler로 X를 변환하고, 모델을 eval + no_grad 모드로 추론해 $y_log = log_{10}(\hat{\sigma})$를 얻는다. 

예측이 훈련 분포 밖으로 튈 때 수치 불안정이나 비현실적인 외삽을 줄이기 위해, 학습 타깃의 0.5 ~ 99.5% 범위를 기준으로 $tanh$ 기반 soft clamp를 적용한 뒤 $10^{y_{soft}}$ 로 $\sigma(t)$를 복원한다.
이는 하드 클리핑 없이 연속적으로 범위를 완만히 눌러 주는 안정화 장치다.

반환값은 길이가 $len(T_in)$인 1D $numpy$ 배열 $\hat{\sigma}$ $[Pa]$이며, 이후 단계에서 rainflow -> $ε–N$  -> Miner 손상 및 수명 계산에 바로 사용된다.

해당 단계에서 $T_{in}(t)$만 시간 변화로 취급하고 나머지 변수는 고정 조건으로 본다는 점, 그리고 훈련과 동일 스케일러/로그베이스($log_{10}$)를 써야 일관된 추론결과가 나온다는 점을 유의하면 된다.

## 15. 변형률 진단: 시나리오 생성 → sigma(t) 예측 → eps(t) 분석(통계/플롯)

이 단계는 실제 운전 중의 온도 변동이 있을 때, 고무 링에 발생하는 변형률 거동을 정량적으로 진단하는 과정이다.

먼저 scenario_noise로 2초 간격, 총 6시간짜리 유입 온도 시나리오 $T_{in}(t)$ 시나리오를 만들고(평균 $80 ^\circ\mathrm{C}$, $±5 ^\circ\mathrm{C}$, 시간상수 $60s$), 이전 단계에서 학습한 MLP 서로게이트로 각 시점의 등가응력 $sigma(t)$를 예측한다. 

기록 길이 record_hours_N는  $\dfrac{len(t_N)\cdot DT_S}{3600.0}$ 로 계산해 시간 단위로 환산하고, 이후 수명 외삽의 기준으로도 쓸 수 있다. 

다음으로 온도의존 탄성계수 $E(T)=E_{25}\exp\(-\beta\(T-25))$를 이용해 각 시점의 변형률 $ε(t) = \dfrac{\sigma}{E(T)}$를 계산하고, 이를 %단위로 환산해 시간 변화에 따른 응력-변형률 응답을 얻는다.

계산된 변형률 시계열을 rainflow 알고리즘에 입력해 사이클별 진폭$ε_a$와 카운트(0.5 또는 1.0)을 구한 뒤, 진폭 분포의 요약 통(min, median, max, p1, p05, p10, p90, p95)를 산출해 변형률의 전체 분포 폭과 지배 진폭 수준을 수치로 확인한다.

특히 피로한계 후보 $ε_e$를 바로 잡을 수 있도록 (1) conservative(하위 10% 커트 - 보수적 컷), (2) typical(중앙값의 50% - 대표적 운전 조건), (3) loose(중앙값의 25%- 느슨한 기준)로 세 가지 대표값을 함께 제시하고 이후 $Miner$ 피로 손상 계산 시 진폭 컷오프 설정의 참고치로 활용된다.

마지막으로 (1) 온도 시나리오 플롯 - 시간에 따른 $T_{in}(t)$ 변동, (2) 변형률 시계열 플롯 -시간에 따른 $ε(t)$ [%] 변화, (3)rainflow 진폭 히스토그램 - 진폭 분포$ε_a$[%] (가중치=사이클 수) 의 세가지 플롯을 제공해 전체 경향을 직관적으로 확인한다.    

히스토그램 x축은 실제 데이터 상단 구간 낭비를 줄이기 위해 $0~min(0.04, max(ε_a))$로 제한하고, 미세한 분포를 보려 bins를 1000개로 설정한다.

결과적으로 해당 단계는 온도–응력–변형률의 시간적 연계, 사이클 분포 통계, 피로한계 후보 도출을 한 번에 수행하는 정량적 변형률 진단 루틴으로, 이후 피로 수명 해석의 입력 조건을 현실적으로 보정하는 데 사용된다.

# Life Prediction

## 16. ε–N 수명 계산 함수: sigma(t) → ε(t) → 레인플로우 → Miner 손상 → 수명[h]

이 단계는 시간축 $t$와 온도 $T_{in}(t)$, 서로게이트가 예측한 응력 $\sigma(t)$ , 재료 상수($E_{25}$, $\beta$)를 받아 $ε–N$ 모델로 누적손상 $D$와 예상 수명 life_hours를 계산한다. 

먼저 온도의존 탄성계수 $E(T)=E_{25}\exp\(-\beta\(T-25))$로 순간 변형률 시계열 $ε(t) = \dfrac{\sigma(t)}{E(T_{in}(t))}$로 만든다.

그다음으로 변형률 파형을 rainflow에 넣어 사이클별 진폭 $ε_a$와 개수 $count$를 얻고, 진폭을 $ε_a = \dfrac{range}{2}$로 정의한 후, 피로한계 $ε_e$이상만 선택하여 고무용 $ε–N$ 관계 $N_f=(\dfrac{ε_0}{ε_a})^b$로 각 사이클의 허용 반복수를 계산한다.

$Miner$ 합산식 $D=\Sigma \dfrac{count}{N_f}$으로 누적 손상을 구하고, 기록 길이를 record_hours = $\dfrac{t_{end}-t_{start}+\Delta t}{3600.0}$ 로 환산하여 예상수명을 life_hours = $\dfrac{\text{record_hours}}{max(D, ε)}$ 로 계산한다(분모 0 방지를 위해 작은 하한 사용)

$\frac{\mathrm{record\_hours}}{\max(D,\varepsilon)}$

반환값은 life_hours, $D$ ,record_hours, rf, $ε(t)$, $ε_a$, $count$ 로 수명 및 손상과 함께 중간 결과(레인플로우 결과/변형률 시계열·진폭/사이클 수)까지 돌려주어 파라미터 $ε_0$, $b$, $ε_e$ 튜닝과 결과 해석에 바로 활용할 수 있다.

## 17. ε–N 기반 손상/수명 계산(요약 실행)

이 단계는 앞에서 준비한 시나리오($t_N$, $T_{in,N}$, $const_N$), 서로게이트 응력 시계열 $\sigma_N(t)$ , 그리고 이전에 정의한 함수 compute_life_eN_from_sigma에 넣어 누적손상 $D$와 예상 수명 life_hours를 한 번에 산출한다. 

입력 파라미터(피로 특성) $ε_0$(기준 변형률), $b$(지수), $ε_e$ (피로한계 진폭)은 고무 피로 특성 및 수명에 직접적인 영향이 크므로 설계 가정에 따라 맞게 설정해야한다.

함수 내부에서는 $E(T)$로부터 변형률 $ε(t)$을 만들고, rainflow로 사이클 진폭 $ε_a$ 및 $count$를 계산한 뒤, $ε–N$ 관계 $N_f=(\dfrac{ε_0}{ε_a})^b$와 $Miner$ 합산으로 $D$를 계산한다. 

출력 로그는 (1) $\sigma_N$의 분포 요약(min, max, std), (2)기록 길이 record_hours, (3) 손상 $D$와 수명 life_hours를 보여준다. 

$D$ 약 1이 설계 한계, life_hours는 record_hours를 $D$로 나눈 결과이며, $ε_e$를 높이면 미세 사이클이 무시되어 수명이 길어지고, 반대로 낮추면 더 보수적인 결과가 나온다.

